# 1. Architecture, Design and Threat Modeling Requirements
Security architecture has almost become a lost art in many organizations. The days of the enterprise architect have passed in the age of DevSecOps. The application security field must catch up and adopt agile security principles while re-introducing leading security architecture principles to software practitioners. Architecture is not an implementation, but a way of thinking about a problem that has potentially many different answers, and no one single "correct" answer. All too often, security is seen as inflexible and demanding that developers fix code in a particular way, when the developers may know a much better way to solve the problem. There is no single, simple solution for architecture, and to pretend otherwise is a disservice to the software engineering field.

##  1.1.1 Verify the use of a secure software development lifecycle that addresses security in all stages of development.
没看懂

## 1.1.2  Verify the use of threat modeling for every design change or sprint planning to identify threats, plan for countermeasures, facilitate appropriate risk responses, and guide security testing.

需要先有一个 high level 的 threat model, 然后随着整个的软件的周期，进行 The ongoing threat modeling process should examine, diagnose, and
address these threats.

##  1.1.3  Verify that all user stories and features contain functional security constraints, such as "As a user, I should be able to view and edit my profile. I should not be able to view or edit anyone else\s profile

验证所有 user 的情况，然后限制他们，例如每个用户只能修改自己的信息

##  1.1.6  Verify implementation of centralized, simple (economy of design); vetted, secure, and reusable security controls to avoid duplicate, missing, ineffective, or insecure controls.

所有的安全验证，错误log和，安全控制，都应该有唯一的地方统一实现和管理。

##  1.10.1  Verify that a source code control system is in use, with procedures to ensure that check-ins are accompanied by issues or change tickets. The source code control system should have access control and identifiable users to allow traceability of any changes.

大型公司用 revision 1、2、3 ... 确定每一个 commit。其中包括，时间，谁上传的，上传的内容，用来追溯上一个，了解发生了什么，备份和 code review

##  1.12.1  Verify that user-uploaded files are stored outside of the web root.

上传的文件应该存储在 web root 以外的地方。用来防止坏人在上传了恶意文件后，解析和执行他们来影响服务器。

##  1.14.3  Verify that the build pipeline warns of out-of-date or insecure components and takes appropriate actions.

安装一些工具，用来周期性的扫描服务器的安全隐患，并给出提示

##  1.14.4  Verify that the build pipeline contains a build step to automatically build and verify the secure deployment of the application, particularly if the application infrastructure is software defined, such as cloud environment build scripts.

##  1.2.1  Verify the use of unique or special low-privilege operating system accounts for all application components, services, and servers.

尝试给与每个用户最少的权限来满足他们的需求

##  1.2.2  Verify that communications between application components, including APIs, middleware and data layers, are authenticated. Components should have the least necessary privileges needed.

给每个应用模块最少的权限

##  1.2.3  Verify that the application uses a single vetted authentication mechanism that is known to be secure, can be extended to include strong authentication, and has sufficient logging and monitoring to detect account abuse or breaches.

##  1.2.4  Verify that all authentication pathways and identity management APIs implement consistent authentication security control strength, such that there are no weaker alternatives per the risk of the application.

##  1.4.1  Verify that trusted enforcement points such as at access control gateways, servers, and serverless functions enforce access controls. Never enforce access controls on the client.

所有的重要的业务逻辑都应该在后端，因为前端的现实可以轻松绕过


##  1.4.3  Verify enforcement of the principle of least privilege in functions, data files, URLs, controllers, services, and other resources. This implies protection against spoofing and elevation of privilege.

根据具体的权限来验证

例如

```
if (user.hasRole("ADMIN")) || (user.hasRole("MANAGER")) {
  deleteAccount();
}
```
```
if (user.hasAccess("DELETE_ACCOUNT")) {
  deleteAccount();
}
```

使用 DELETE_ACCOUNT 要好，更加灵活和可扩展

##  1.6.1  Verify that there is an explicit policy for management of cryptographic keys and that a cryptographic key lifecycle follows a key management standard such as NIST SP 800-57.

Key management and key lifecycle by NIST

##  1.6.2  Verify that consumers of cryptographic services protect key material and other secrets by using key vaults or API based alternatives.

##  1.6.3  Verify that all keys and passwords are replaceable and are part of a well-defined process to re-encrypt sensitive data.

程序中需要秘钥的组件的秘钥是可以更改和替换的，用以阻止一些内部人员的变动带来的泄露风险


##  1.6.4  Verify that symmetric keys, passwords, or API secrets generated by or shared with clients are used only in protecting low risk secrets, such as encrypting local storage, or temporary ephemeral uses such as parameter obfuscation. Sharing secrets with clients is clear-text equivalent and architecturally should be treated as such.

用对称秘钥加密的信息不应该是重要的信息

##  1.8.1  Verify that all sensitive data is identified and classified into protection levels.

##  1.8.2  Verify that all protection levels have an associated set of protection requirements, such as encryption requirements, integrity requirements, retention, privacy and other confidentiality requirements, and that these are applied in the architecture.
